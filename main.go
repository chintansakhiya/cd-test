package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	v1 "k8s.io/api/batch/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/watch"

	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"

	"github.com/go-resty/resty/v2"
	"github.com/gofiber/fiber/v2"
	"github.com/spf13/cobra"
)

type AutoGenerated struct {
	Attachments []Attachment `json:"attachments"`
}

type Fields struct {
	Short bool   `json:"short"`
	Title string `json:"title"`
	Value string `json:"value"`
}

type Attachment struct {
	Fallback   string   `json:"fallback"`
	Color      string   `json:"color"`
	Pretext    string   `json:"pretext"`
	Text       string   `json:"text"`
	AuthorName string   `json:"author_name"`
	AuthorIcon string   `json:"author_icon"`
	AuthorLink string   `json:"author_link"`
	Title      string   `json:"title"`
	TitleLink  string   `json:"title_link"`
	Fields     []Fields `json:"fields"`
	ImageURL   string   `json:"image_url"`
}

func main() {
	sendMessage := sendMessage()
	apiCmd := api()
	cronJob := GetCronJobDetails()
	rootCmd := &cobra.Command{Use: "test-api"}
	rootCmd.AddCommand(&sendMessage, &apiCmd, &cronJob)
	err := rootCmd.Execute()
	if err != nil {
		fmt.Println(err)
	}
}

func sendMessage() cobra.Command {
	sendMessageCmd := cobra.Command{
		Use:   "send-message",
		Short: "Send message to slack",
		RunE: func(cmd *cobra.Command, args []string) error {
			resty := resty.New()
			res, err := resty.R().SetBody(AutoGenerated{
				Attachments: []Attachment{
					{
						Fallback: "Required plain-text summary of the attachment.",
						Color:    "#36a64f",

						AuthorName: "cron-job",
						Title:      "cron-job run successfully",
						// TitleLink: "https://api.slack.com/",

					},
				},
			}).
				Post("https://talk.improwised.com/hooks/hhwqd3yp43yemrprn1m19cqibo")
			fmt.Println(res)
			return err
		},
	}
	return sendMessageCmd
}

func api() cobra.Command {
	apiCmd := cobra.Command{
		Use:   "api",
		Short: "Call api",
		RunE: func(cmd *cobra.Command, args []string) error {
			fiberapp := fiber.New()
			fiberapp.Get("/", func(c *fiber.Ctx) error {
				 
				return fmt.Errorf("this is a custom error")

			})

			fiberapp.Get("/api", func(c *fiber.Ctx) error {
				return c.JSON(fiber.Map{"message": "Hello, World ðŸ‘‹!",})
			
			})

			fiberapp.Get("/api/v1", func(c *fiber.Ctx) error {
				return c.JSON(fiber.Map{"message": "Hello, World ðŸ‘‹!",})
			
			})

			fiberapp.Get("/api/v3", func(c *fiber.Ctx) error {
				return c.JSON(fiber.Map{"message": "Hello, World ðŸ‘‹!",})
			
			})


			fiberapp.Get("/api/v2", func(c *fiber.Ctx) error {
				return c.JSON(fiber.Map{"message": "Hello, World ðŸ‘‹!",})
			
			})

			fiberapp.Get("/healthz", func(c *fiber.Ctx) error {
				return c.SendString("okok")
			})



			return fiberapp.Listen(":3333")
		},
	}
	return apiCmd
}

func GetCronJobDetails() cobra.Command {
	cronJob := cobra.Command{
		Use:  "cron-job",
		Long: "Get cron job details",
		RunE: func(cmd *cobra.Command, args []string) error {
			// ListCronJob()
			// watchCronjob()
			// sql()
			throwError()
			return nil
		},
	}
	return cronJob
}

//--------------------------------------------------------------------------------

var clientset *kubernetes.Clientset

func GetKubeConfig() string {
	kubeconfigPath := os.Getenv("KUBECONFIG")
	if kubeconfigPath == "" {
		kubeconfigPath = filepath.Join(homedir.HomeDir(), ".kube", "config")
	}

	// Validate if the file exists
	var kubeconfig *string
	if _, err := os.Stat(kubeconfigPath); os.IsNotExist(err) {
		flag.StringVar(kubeconfig, "nammme", "absolute path to the kubeconfig file", "nathi kbr")
	}
	return kubeconfigPath
}

// --------------------------------------------------------------------------------
func ListCronJob() {
	kubeconfig := GetKubeConfig()
	config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		log.Fatal(err)
	}

	clientset, err = kubernetes.NewForConfig(config)
	if err != nil {
		log.Fatal(err)
	}

	namespaces, err := clientset.CoreV1().Namespaces().List(context.Background(), metav1.ListOptions{})
	if err != nil {
		log.Fatal("error while gating name space", err)
	}
	for _, ns := range namespaces.Items {
		cronJobsClient := clientset.BatchV1().CronJobs(ns.Name)

		data, err := cronJobsClient.List(context.TODO(), metav1.ListOptions{})
		if err != nil {
			log.Fatal("failed to create cron job", err)
		}

		// data1:=data.ListMeta
		// data1, err := json.Marshal(data)
		for _, cj := range data.Items {
			fmt.Println("name: ", cj.Name, "  Schedule: ", cj.Spec.Schedule)
		}
	}

}

func watchCronjob() {
	kubeconfig := GetKubeConfig()
	config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		log.Fatal(err)
	}

	clientset, err = kubernetes.NewForConfig(config)
	if err != nil {
		log.Fatal(err)
	}

	cronJobsClient, err := clientset.BatchV1().CronJobs("").Watch(context.Background(), metav1.ListOptions{})

	if err != nil {
		log.Fatal("failed to create cron job", err)
	}
	for event := range cronJobsClient.ResultChan() {
		if event.Type == watch.Error {
			// Handle errors
			errStatus, ok := event.Object.(*metav1.Status)
			if !ok {
				fmt.Println("Unexpected error type")
				continue
			}
			fmt.Printf("Error watching CronJobs: %s\n", errStatus.Message)
			continue
		}
		cronJob, ok := event.Object.(*v1.CronJob)
		if !ok {
			fmt.Println("Unexpected object type")
			continue
		}
		switch event.Type {
		case watch.Added:

			fmt.Printf("CronJob added \n")
			fmt.Printf("name: %s\n", cronJob.Name)
			// fmt.Printf("name: %s\n", cronJob)
		case watch.Modified:
			fmt.Printf("CronJob modified:")
			fmt.Printf("	- name %v\n", cronJob.Name)
			fmt.Printf("	- status %v\n", cronJob.Status)
		case watch.Deleted:
			fmt.Printf("CronJob deleted: %s\n", cronJob.Name)
		case watch.Bookmark:
			// Do nothing for bookmark events
		default:
			fmt.Println("Unknown event type")
		}
	}

}

func throwError() {
	time.Sleep(10 * time.Second)
	log.Panic("this is a custom error")
}